// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "fmt"
import "reflect"
import "encoding/json"

type Obfuscate struct {
	// The list of domains and their subdomains which should be obfuscated in the
	// output, only used with the type Domain obfuscator.
	DomainNames []string `json:"domainNames,omitempty" yaml:"domainNames,omitempty"`

	// when replacementType 'Regex' is used, the supplied Golang regexp
	// (https://pkg.go.dev/regexp) will be used to detect the string that should be
	// replaced. The regex is line based, spanning multi-line regex statements is not
	// supported.
	Regex *string `json:"regex,omitempty" yaml:"regex,omitempty"`

	// on replacement 'Keywords', this will override a given input string with another
	// output string. On duplicate keys it will use the last defined value as
	// replacement. The input values are matched in a case-sensitive fashion and only
	// as a full words, substrings must be matched using a regex.
	Replacement ObfuscateReplacement `json:"replacement,omitempty" yaml:"replacement,omitempty"`

	// This defines how the detected string will be replaced. Type 'Consistent' will
	// guarantee the same input will always create the same output string. 'Static' is
	// used by default and will just try to mask the matching input.
	ReplacementType ObfuscateReplacementType `json:"replacementType,omitempty" yaml:"replacementType,omitempty"`

	// This determines if the obfuscation should be performed on the file path
	// (relative path from the must-gather root folder) or on the file contents. The
	// file contents are obfuscated by default.
	Target ObfuscateTarget `json:"target,omitempty" yaml:"target,omitempty"`

	// type defines the kind of detection you want to use. For example IP will find IP
	// addresses, whereas Keywords will find keywords defined in the 'replacement'
	// mapping. Domain must be used in conjunction with the 'domainNames' property,
	// that defines what domains should be obfuscated. MAC currently only supports
	// static replacement where a detected mac address will be replaced by 'x'. Regex
	// should be used with the 'regex' property that will define the regex, here the
	// replacement also will be static by 'x'-ing out the matched string.
	Type ObfuscateType `json:"type" yaml:"type"`
}

// on replacement 'Keywords', this will override a given input string with another
// output string. On duplicate keys it will use the last defined value as
// replacement. The input values are matched in a case-sensitive fashion and only
// as a full words, substrings must be matched using a regex.
type ObfuscateReplacement map[string]string

type ObfuscateReplacementType string

const ObfuscateReplacementTypeConsistent ObfuscateReplacementType = "Consistent"
const ObfuscateReplacementTypeStatic ObfuscateReplacementType = "Static"

type ObfuscateTarget string

const ObfuscateTargetAll ObfuscateTarget = "All"
const ObfuscateTargetFileContents ObfuscateTarget = "FileContents"
const ObfuscateTargetFilePath ObfuscateTarget = "FilePath"

type ObfuscateType string

const ObfuscateTypeDomain ObfuscateType = "Domain"
const ObfuscateTypeIP ObfuscateType = "IP"
const ObfuscateTypeKeywords ObfuscateType = "Keywords"
const ObfuscateTypeMAC ObfuscateType = "MAC"
const ObfuscateTypeRegex ObfuscateType = "Regex"

type Omit struct {
	// KubernetesResource corresponds to the JSON schema field "kubernetesResource".
	KubernetesResource *OmitKubernetesResource `json:"kubernetesResource,omitempty" yaml:"kubernetesResource,omitempty"`

	// A file glob pattern on file paths relative to the must-gather root. The pattern
	// should be as described in https://pkg.go.dev/path/filepath#Match
	Pattern *string `json:"pattern,omitempty" yaml:"pattern,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type OmitType `json:"type" yaml:"type"`
}

type OmitKubernetesResource struct {
	// This defines the apiVersion of the kubernetes resource. That can be used to
	// further refine specific versions of a resource that should be omitted.
	ApiVersion *string `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty"`

	// This defines the kind of kubernetes resource that should be omitted. This can
	// be further specified with the apiVersion and namespaces.
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty"`

	// This defines the namespaces which are supposed to be omitted. When used
	// together with kind and apiVersions, it becomes a filter. Standalone it will be
	// used as a filter for all resources in a given namespace.
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OmitType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OmitType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OmitType, v)
	}
	*j = OmitType(v)
	return nil
}

var enumValues_ObfuscateTarget = []interface{}{
	"FilePath",
	"FileContents",
	"All",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ObfuscateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ObfuscateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ObfuscateType, v)
	}
	*j = ObfuscateType(v)
	return nil
}

var enumValues_ObfuscateReplacementType = []interface{}{
	"Consistent",
	"Static",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Obfuscate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain Obfuscate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["replacementType"]; !ok || v == nil {
		plain.ReplacementType = "Static"
	}
	if v, ok := raw["target"]; !ok || v == nil {
		plain.Target = "FileContents"
	}
	*j = Obfuscate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ObfuscateTarget) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ObfuscateTarget {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ObfuscateTarget, v)
	}
	*j = ObfuscateTarget(v)
	return nil
}

type OmitType string

var enumValues_OmitType = []interface{}{
	"Kubernetes",
	"File",
	"SymbolicLink",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ObfuscateReplacementType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ObfuscateReplacementType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ObfuscateReplacementType, v)
	}
	*j = ObfuscateReplacementType(v)
	return nil
}

const OmitTypeKubernetes OmitType = "Kubernetes"
const OmitTypeFile OmitType = "File"
const OmitTypeSymbolicLink OmitType = "SymbolicLink"

var enumValues_ObfuscateType = []interface{}{
	"Domain",
	"IP",
	"Keywords",
	"MAC",
	"Regex",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Omit) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain Omit
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Omit(plain)
	return nil
}

// There are two main sections, "omit" which defines the omission behaviour and
// "obfuscate" which defines the obfuscation behaviour.
type SchemaJsonConfig struct {
	// The obfuscation schema determines what is being detected and how it is being
	// replaced. We ship with several built-in replacements for common types such as
	// IP or MAC, Keywords and Regex. The replacements are done in order of the whole
	// list, so you can define chains of replacements that built on top of one another
	// - for example replacing a keyword and later matching its replacement with a
	// regex. The input to the given replacements are always a line of text (string).
	// Since file names and directories can also have private content in them, they
	// are also processed as a line - exactly as they would with file content.
	Obfuscate []Obfuscate `json:"obfuscate,omitempty" yaml:"obfuscate,omitempty"`

	// The omission schema defines what kind of files shall not be included in the
	// final must-gather. This can be seen as a filter and can operate on file paths
	// or Kubernetes and OpenShift and other custom resources. Omissions are settled
	// first in the process of obfuscating a must-gather, so its content won't be
	// scanned and replaced.
	Omit []Omit `json:"omit,omitempty" yaml:"omit,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJsonConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SchemaJsonConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Obfuscate) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "obfuscate", 1)
	}
	*j = SchemaJsonConfig(plain)
	return nil
}

// This configuration defines the behaviour of the must-gather-clean CLI. The CLI
// helps to obfuscate and omit output from OpenShift debug information
// ('must-gathers'). You can find more information in our GitHub repository at
// https://github.com/openshift/must-gather-clean.
type SchemaJson struct {
	// There are two main sections, "omit" which defines the omission behaviour and
	// "obfuscate" which defines the obfuscation behaviour.
	Config SchemaJsonConfig `json:"config" yaml:"config"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["config"]; !ok || v == nil {
		return fmt.Errorf("field config: required")
	}
	type Plain SchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SchemaJson(plain)
	return nil
}
